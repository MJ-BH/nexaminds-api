# Nexaminds Backend Technical Test (TypeScript Edition) üöÄ

A production-grade **Microservices Architecture** built with **Node.js** and **TypeScript**, featuring asynchronous event-driven communication, strictly typed interfaces, and robust error handling.

This project demonstrates a migration from standard JavaScript to a scalable **TypeScript** ecosystem.

---

## üèóÔ∏è Architecture Overview

The system is composed of four containerized services orchestrated via Docker Compose:

1.  **üö™ API Gateway (Port 3000):**
    *   The single entry point for all client requests.
    *   Routes traffic to internal microservices.
    *   Aggregates **Swagger Documentation** from all services into a unified UI.
    
2.  **üîê Auth Service (Port 3001):**
    *   **Stack:** TypeScript, Express, Mongoose, JWT.
    *   **Role:** Manages User Registration, Login, and Database persistence.
    *   **Pattern:** Exposes internal APIs to allow decoupled data access from other services.

3.  **‚öôÔ∏è URL Builder Service (Port 3002):**
    *   **Stack:** TypeScript, Axios.
    *   **Role:** Handles complex business logic (Median/Duration calculations) and orchestrates the workflow between Auth and Email services.
    
4.  **üìß Email Service (Port 3003):**
    *   **Stack:** TypeScript, RabbitMQ (amqplib), Nodemailer.
    *   **Role:** A Hybrid Service (REST API + Background Worker).
    *   **Resilience:** Uses an **Exponential Retry Strategy** (Max 3 retries) to handle failures without data loss.

---

## ‚ú® Key Features (Senior Implementation)

*   **TypeScript Strict Mode:** Full migration to TypeScript with Interface definitions for Data Models, API Responses, and Message Payloads.
*   **Asynchronous Queuing:** High-volume email dispatching is decoupled using **RabbitMQ**, ensuring the API remains fast and responsive.
*   **Resilient Worker:** The Email Worker prevents infinite loops by tracking retry counts and gracefully handling failures.
*   **Multi-Stage Docker Builds:** Optimized Dockerfiles compile TypeScript to JavaScript in a build stage, resulting in smaller, faster production images.
*   **Centralized Documentation:** Dynamic Swagger UI aggregation allows testing all services from a single interface.
*   **CI/CD Pipeline:** GitHub Actions workflow handles Linting, Security Audits, **TypeScript Compilation Checks**, and Parallel Unit Testing.

---

## üöÄ Quick Start

### Prerequisites
*   **Docker Desktop**
*   **Git**

### Installation & Running

1.  **Clone the repository:**
    ```bash
    git clone <your-repo-url>
    cd nexaminds-test
    ```

2.  **Switch to the TypeScript branch (if applicable):**
    ```bash
    git checkout refactor/typescript
    ```

3.  **Start the ecosystem:**
    ```bash
    docker compose up --build
    ```

4.  **Access the System:**
    *   **Unified API Docs (Swagger):** [http://localhost:3000](http://localhost:3000)
    *   **RabbitMQ Management:** [http://localhost:15672](http://localhost:15672) (User: guest / Pass: guest)

---

## üß™ Testing Guide

### 1. Automated Unit Tests (ts-jest)
The project uses `ts-jest` to run tests directly against TypeScript source files without pre-compilation. All external dependencies (MongoDB, RabbitMQ, Axios) are **Mocked**.

```bash
# Run tests for a specific service
cd auth-service && npm test
cd ../url-builder-service && npm test
cd ../email-service && npm test